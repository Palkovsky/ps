#+TITLE: Programowanie systemowe - Wprowadzenie - Raport z ćwiczenia
#+SUBTITLE: Dawid Macek
#+LANGUAGE: pl
#+OPTIONS: date:nil
#+OPTIONS: toc:nil
#+OPTIONS: num:nil
#+OPTIONS: html-postamble:nil
#+HTML_HEAD: <style>pre.src {background-color: #303030; color: #e5e5e5;}</style>

* Zadanie 1 - LXR i dokumentacja

* Zadanie 2 - kompilacja jądra
  Będę pracował na swojej wirtualnej maszynie i jądrze 5.5.

** Setup
   #+CAPTION: Tworzę katalog ~/usr/src/kernels~
   #+begin_src bash
   >> mkdir /usr/src/kernels
   >> cd /usr/src/kernels
   #+end_src

   #+CAPTION: Pobieram jądro 5.5.
   #+begin_src bash
   >> wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.5.13.tar.xz
   >> tar -xf linux-5.5.13.tar.xz
   #+end_src
   
   #+CAPTION: Tworzę linka symbolicznego, żeby nie musieć pamiętać nazwy.
   #+begin_src bash
   >> ln -s /usr/src/kernels/linux-5.5.13 /usr/src/kernels/linux
   #+end_src

   #+CAPTION: Kopiuję i rozpakowywuję plik ~.config~.
   #+begin_src bash
     >> cp /proc/config.gz .
     >> gunzip config.gz
     >> mv config .config
   #+end_src

** Co robi polecenie ~make oldconfig~? Wykonaj je.
   #+CAPTION: Opis ~make oldconfig~
   #+begin_src bash
   >> make help | grep oldconfig
   oldconfig       - Update current config utilising a provided .config as base
   olddefconfig    - Same as oldconfig but sets new symbols to their
   #+end_src

   ~make oldconfig~ updatuje ~.config~ wykorzystując stary plik jako bazę.
   Skrypt ten może być przydatny przy migracji do innej wersji jądra.

   Gdy w innej wersji pojawi się nowa opcja, to nowy ~.config~ będzie miał domyślną wartość.
   Gdy w innej wersji nie będzie danej opcji, to zostanie ona zignorowana.
   Gdy w innej wersji będzie dana opcja, to będzie oan taka jak w starym ~.config~.

   Nie umieszczam outputu z konsoli, bo jest tak długi jak ilość linii w pliku.

** Co robi polecenie ~make menuconfig~? Wykonaj je.
   #+CAPTION: Opis ~make menuconfig~
   #+begin_src bash
   >> make help | grep menuconfig
   menuconfig      - Update current config utilising a menu based program
   #+end_src

   ~make menuconfig~ pozwala na skonfigurowanie jądra za pomocą interfejsu graficznego.
   
   #+CAPTION: Tak wygląda interfejs ~make menuconfig~
   [[./imgs/2_1.png]]

** Ustaw dowolną, ale charakterystyczną wersję lokalną (CONFIG​_LOCALVERSION albo General setup/Local version).
   #+CAPTION: Ustawienie CONFIG​_LOCALVERSION za pomocą ~make menuconfig~
   [[./imgs/2_2.png]]
   
   #+CAPTION: Po zapisaniu za pomocą ~make menuconfig~ zmiana zostaje wprowadzaona do pliku
   #+begin_src bash
   >> cat .config | grep LOCALVERSION
   CONFIG_LOCALVERSION="KOPYTKO"
   # CONFIG_LOCALVERSION_AUTO is not set
   #+end_src
** Zrób małą zmianę w konfiguracji (np. włącz obsługę któregoś systemu plików).
   #+CAPTION: ~ADFS~ zostało włączone
   [[./imgs/2_3.png]]
** Co robi polecenie ~make all~?
   #+begin_src 
   all             - Build all targets marked with [*]
   #+end_src

   Polecenie powinno skompilować jądro i moduły.
   W jądro wkompilowywane są opcje oznaczone [*].
   Opcje oznaczone jako <M> kompilowane są jako moduły.

** Co robią polecenia make ~modules_install~ i ~make install~?
   #+CAPTION: Opis ~make modules_install~ i ~make install~
   #+begin_src bash
   >> make help | grep install
   modules_install - Install all modules to INSTALL_MOD_PATH (default: /)
   headers_install - Install sanitised kernel headers to INSTALL_HDR_PATH
                     Build, install, and boot kernel before
   install         - Install kernel using
                     (your) ~/bin/installkernel or
                     (distribution) /sbin/installkernel or
                     install to $(INSTALL_PATH) and run lilo
   #+end_src

   ~make modules_install~ przeprowadzi instalację modułów jądra. 
   Czyli w praktyce przeniesie je do jakiegoś konkretnego miejsca, z którego jądro będzie w stanie je ładować.

   ~make install~ przeprowadzi instalację jądra.
   Czyli umieści je w jakimś ustalonym miejscu, tak żeby bootloader je zobaczył.

** Skompiluj jądro po zmianie i zmierz czas kompilacji (komenda time). Jakie informacje wyświetlają się podczas kompilacji?
   #+begin_src bash
   >>time (make all -j8 MARCH=x86-64)
   8538,32s user 1265,58s system 773% cpu 21:07,60 total
   #+end_src

   Podczas kompilacji wyświetlają się nazwy powstałych plików obiektowych.
   Pojawia się też oznaczenie [M] w zależności czy dana funkcjonalność będzie realizowana jako moduł.
   Potem wszystko jest ze sobą linkowane i powstaje obraz jądra.

   Kompilowało się 21 minut i 7 sekund.

** Zainstaluj jądro w systemie.
   #+CAPTION: Instalacja modułów, jądra i dla pewności aktualizacja GRUBa
   #+begin_src bash
   >> make modules_install
   # ...
   >> cp -v arch/x86_64/boot/bzImage /boot/vmlinuz-5.5.13-KOPYTKO
   >> cp System.map /boot/System.map-5.5.13-KOPYTKO 
   >> mkinitcpio -k 5.5.13-KOPYTKO -g /boot/initramfs-5.5.13-KOPYTKO.img
   # ...
   >> update-grub
   Generating grub configuration file ...
   Found theme: /usr/share/grub/themes/manjaro/theme.txt
   Found linux image: /boot/vmlinuz-5.5.13-KOPYTKO
   Found initrd image: /boot/intel-ucode.img /boot/amd-ucode.img /boot/initramfs-5.5.13-KOPYTKO.img
   Found linux image: /boot/vmlinuz-5.5-x86_64
   Found initrd image: /boot/intel-ucode.img /boot/amd-ucode.img /boot/initramfs-5.5-x86_64.img
   Found initrd fallback image: /boot/initramfs-5.5-x86_64-fallback.img
   Found memtest86+ image: /boot/memtest86+/memtest.bin
   #+end_src

   #+CAPTION: Nowe jądro jest widoczne w GRUBie
   [[./imgs/2_4.png]]

   #+CAPTION: Po zbootowaniu
   [[./imgs/2_5.png]]

* Zadanie 3 - kompilacja modułu
  Nie mam przykładowego modułu, dlatego posłużę się poniższym:
  
  #+CAPTION: ~hello.c~
  #+begin_src c
#include<linux/kernel.h>
#include<linux/module.h>
#include<linux/init.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("A Simple Hello World module");

static int __init hello_init(void)
{
  printk(KERN_INFO "Hello world!\n");
  return 0;
}

static void __exit hello_cleanup(void)
{
  printk(KERN_INFO "Goodbye world.\n");
}

module_init(hello_init);
module_exit(hello_cleanup);

  #+end_src

  #+CAPTION: ~Makefile~
  #+begin_src Makefile
obj-m += hello.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean  
  #+end_src

  #+CAPTION: Zbudowanie modułu
  #+begin_src bash
>> make
make -C /lib/modules/5.5.13-KOPYTKO/build M=/tmp modules
make[1]: Wejście do katalogu '/usr/src/kernels/linux-5.5.13'
  CC [M]  /tmp/hello.o
  Building modules, stage 2.
  MODPOST 1 modules
  CC [M]  /tmp/hello.mod.o
  LD [M]  /tmp/hello.ko
make[1]: Opuszczenie katalogu '/usr/src/kernels/linux-5.5.13'
  #+end_src

** Załaduj za pomocą ~insmod~
   #+CAPTION: Ładowanie za pomocą ~insmod~
   #+begin_src bash
   >> sudo insmod hello.ko
   #+end_src
** Wylistuj za pomocą ~lsmod~
   #+CAPTION: Listowanie za pomocą ~lsmod~
   #+begin_src bash
>>> sudo lsmod
Module                  Size  Used by
hello                  16384  0                       # Nasz moduł
xt_conntrack           16384  1
xt_MASQUERADE          20480  1
nf_conntrack_netlink    57344  0
nfnetlink              16384  2 nf_conntrack_netlink
xfrm_user              45056  1
xfrm_algo              16384  1 xfrm_user
xt_addrtype            16384  2
iptable_filter         16384  1
iptable_nat            16384  1
# ...
   #+end_src

** Obejrzyj komunikaty jądra za pomocą ~dmesg~
   #+CAPTION: Wyświetlenie komunikatów po załadowaniu modułu.
   #+begin_src bash
>>> sudo insmod hello.ko
>>> sudo dmesg | tail
[ 2314.602080] audit: type=1104 audit(1585237700.183:211): pid=6479 uid=0 auid=1000 ses=3 msg='op=PAM:setcred grantors=pam_unix,pam_permit,pam_env acct="root" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2336.867110] audit: type=1101 audit(1585237722.447:212): pid=6511 uid=1000 auid=1000 ses=3 msg='op=PAM:accounting grantors=pam_unix,pam_permit,pam_time acct="andrzej" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2336.867197] audit: type=1110 audit(1585237722.447:213): pid=6511 uid=0 auid=1000 ses=3 msg='op=PAM:setcred grantors=pam_unix,pam_permit,pam_env acct="root" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2336.867991] audit: type=1105 audit(1585237722.447:214): pid=6511 uid=0 auid=1000 ses=3 msg='op=PAM:session_open grantors=pam_limits,pam_unix,pam_permit acct="root" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2336.869234] Hello world!
[ 2336.869485] audit: type=1106 audit(1585237722.450:215): pid=6511 uid=0 auid=1000 ses=3 msg='op=PAM:session_close grantors=pam_limits,pam_unix,pam_permit acct="root" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2336.869528] audit: type=1104 audit(1585237722.450:216): pid=6511 uid=0 auid=1000 ses=3 msg='op=PAM:setcred grantors=pam_unix,pam_permit,pam_env acct="root" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2338.100884] audit: type=1101 audit(1585237723.680:217): pid=6521 uid=1000 auid=1000 ses=3 msg='op=PAM:accounting grantors=pam_unix,pam_permit,pam_time acct="andrzej" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2338.100971] audit: type=1110 audit(1585237723.680:218): pid=6521 uid=0 auid=1000 ses=3 msg='op=PAM:setcred grantors=pam_unix,pam_permit,pam_env acct="root" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2338.101796] audit: type=1105 audit(1585237723.683:219): pid=6521 uid=0 auid=1000 ses=3 msg='op=PAM:session_open grantors=pam_limits,pam_unix,pam_permit acct="root" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
   #+end_src

** Usuń za pomocą ~rmmod~ i wyświetl komunikaty jądra.
#+CAPTION: Wyświetlenie komunikatów po usunięciu modułu.
   #+begin_src bash
>>> sudo rmmod hello
>>> sudo dmesg | tail
[ 2338.108594] audit: type=1104 audit(1585237723.690:221): pid=6521 uid=0 auid=1000 ses=3 msg='op=PAM:setcred grantors=pam_unix,pam_permit,pam_env acct="root" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2496.807056] audit: type=1101 audit(1585237882.387:222): pid=6561 uid=1000 auid=1000 ses=3 msg='op=PAM:accounting grantors=pam_unix,pam_permit,pam_time acct="andrzej" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2496.807138] audit: type=1110 audit(1585237882.387:223): pid=6561 uid=0 auid=1000 ses=3 msg='op=PAM:setcred grantors=pam_unix,pam_permit,pam_env acct="root" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2496.807971] audit: type=1105 audit(1585237882.387:224): pid=6561 uid=0 auid=1000 ses=3 msg='op=PAM:session_open grantors=pam_limits,pam_unix,pam_permit acct="root" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2496.808780] Goodbye world.
[ 2496.839289] audit: type=1106 audit(1585237882.420:225): pid=6561 uid=0 auid=1000 ses=3 msg='op=PAM:session_close grantors=pam_limits,pam_unix,pam_permit acct="root" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2496.839337] audit: type=1104 audit(1585237882.420:226): pid=6561 uid=0 auid=1000 ses=3 msg='op=PAM:setcred grantors=pam_unix,pam_permit,pam_env acct="root" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2498.034229] audit: type=1101 audit(1585237883.613:227): pid=6569 uid=1000 auid=1000 ses=3 msg='op=PAM:accounting grantors=pam_unix,pam_permit,pam_time acct="andrzej" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2498.034315] audit: type=1110 audit(1585237883.613:228): pid=6569 uid=0 auid=1000 ses=3 msg='op=PAM:setcred grantors=pam_unix,pam_permit,pam_env acct="root" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2498.035112] audit: type=1105 audit(1585237883.617:229): pid=6569 uid=0 auid=1000 ses=3 msg='op=PAM:session_open grantors=pam_limits,pam_unix,pam_permit acct="root" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'   
   #+end_src

** Zapoznaj się z dokładniej z komendą ~dmseg~
   Kilka przydatnych opcji.
   #+begin_example
   -w - opcja pozwala na obserwowanie komunikatów na żyw
   -H, --human - opcja dodaje kolorowanie
   --level=... - pozwala na filtrowanie wiadomości np. tylko błędy
   #+end_example

* Zadanie 4 - uruchamianie jądra w QEMU
