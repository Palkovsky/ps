#+TITLE: Programowanie systemowe - Wprowadzenie - Raport z ćwiczenia
#+SUBTITLE: Dawid Macek
#+LANGUAGE: pl
#+OPTIONS: date:nil
#+OPTIONS: toc:nil
#+OPTIONS: num:nil
#+OPTIONS: html-postamble:nil
#+HTML_HEAD: <style>pre.src {background-color: #303030; color: #e5e5e5;}</style>

* Zadanie 1 - LXR i dokumentacja

* Zadanie 2 - kompilacja jądra
  Będę pracował na swojej wirtualnej maszynie i jądrze 5.5.

** Setup
   #+CAPTION: Tworzę katalog ~/usr/src/kernels~
   #+begin_src bash
   >> mkdir /usr/src/kernels
   >> cd /usr/src/kernels
   #+end_src

   #+CAPTION: Pobieram jądro 5.5.
   #+begin_src bash
   >> wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.5.13.tar.xz
   >> tar -xf linux-5.5.13.tar.xz
   #+end_src

   #+CAPTION: Tworzę linka symbolicznego, żeby nie musieć pamiętać nazwy.
   #+begin_src bash
   >> ln -s /usr/src/kernels/linux-5.5.13 /usr/src/kernels/linux
   #+end_src

   #+CAPTION: Kopiuję i rozpakowywuję plik ~.config~.
   #+begin_src bash
     >> cp /proc/config.gz .
     >> gunzip config.gz
     >> mv config .config
   #+end_src

** Co robi polecenie ~make oldconfig~? Wykonaj je.
   #+CAPTION: Opis ~make oldconfig~
   #+begin_src bash
   >> make help | grep oldconfig
   oldconfig       - Update current config utilising a provided .config as base
   olddefconfig    - Same as oldconfig but sets new symbols to their
   #+end_src

   ~make oldconfig~ updatuje ~.config~ wykorzystując stary plik jako bazę.
   Skrypt ten może być przydatny przy migracji do innej wersji jądra.

   Gdy w innej wersji pojawi się nowa opcja, to nowy ~.config~ będzie miał domyślną wartość.
   Gdy w innej wersji nie będzie danej opcji, to zostanie ona zignorowana.
   Gdy w innej wersji będzie dana opcja, to będzie oan taka jak w starym ~.config~.

   Nie umieszczam outputu z konsoli, bo jest tak długi jak ilość linii w pliku.

** Co robi polecenie ~make menuconfig~? Wykonaj je.
   #+CAPTION: Opis ~make menuconfig~
   #+begin_src bash
   >> make help | grep menuconfig
   menuconfig      - Update current config utilising a menu based program
   #+end_src

   ~make menuconfig~ pozwala na skonfigurowanie jądra za pomocą interfejsu graficznego.

   #+CAPTION: Tak wygląda interfejs ~make menuconfig~
   [[./imgs/2_1.png]]

** Ustaw dowolną, ale charakterystyczną wersję lokalną (CONFIG​_LOCALVERSION albo General setup/Local version).
   #+CAPTION: Ustawienie CONFIG​_LOCALVERSION za pomocą ~make menuconfig~
   [[./imgs/2_2.png]]

   #+CAPTION: Po zapisaniu za pomocą ~make menuconfig~ zmiana zostaje wprowadzaona do pliku
   #+begin_src bash
   >> cat .config | grep LOCALVERSION
   CONFIG_LOCALVERSION="KOPYTKO"
   # CONFIG_LOCALVERSION_AUTO is not set
   #+end_src
** Zrób małą zmianę w konfiguracji (np. włącz obsługę któregoś systemu plików).
   #+CAPTION: ~ADFS~ zostało włączone
   [[./imgs/2_3.png]]
** Co robi polecenie ~make all~?
   #+begin_src
   all             - Build all targets marked with [*]
   #+end_src

   Polecenie powinno skompilować jądro i moduły.
   W jądro wkompilowywane są opcje oznaczone [*].
   Opcje oznaczone jako <M> kompilowane są jako moduły.

** Co robią polecenia make ~modules_install~ i ~make install~?
   #+CAPTION: Opis ~make modules_install~ i ~make install~
   #+begin_src bash
   >> make help | grep install
   modules_install - Install all modules to INSTALL_MOD_PATH (default: /)
   headers_install - Install sanitised kernel headers to INSTALL_HDR_PATH
                     Build, install, and boot kernel before
   install         - Install kernel using
                     (your) ~/bin/installkernel or
                     (distribution) /sbin/installkernel or
                     install to $(INSTALL_PATH) and run lilo
   #+end_src

   ~make modules_install~ przeprowadzi instalację modułów jądra.
   Czyli w praktyce przeniesie je do jakiegoś konkretnego miejsca, z którego jądro będzie w stanie je ładować.

   ~make install~ przeprowadzi instalację jądra.
   Czyli umieści je w jakimś ustalonym miejscu, tak żeby bootloader je zobaczył.

** Skompiluj jądro po zmianie i zmierz czas kompilacji (komenda time). Jakie informacje wyświetlają się podczas kompilacji?
   #+begin_src bash
   >>time (make all -j8 MARCH=x86-64)
   8538,32s user 1265,58s system 773% cpu 21:07,60 total
   #+end_src

   Podczas kompilacji wyświetlają się nazwy powstałych plików obiektowych.
   Pojawia się też oznaczenie [M] w zależności czy dana funkcjonalność będzie realizowana jako moduł.
   Potem wszystko jest ze sobą linkowane i powstaje obraz jądra.

   Kompilowało się 21 minut i 7 sekund.

** Zainstaluj jądro w systemie.
   #+CAPTION: Instalacja modułów, jądra i dla pewności aktualizacja GRUBa
   #+begin_src bash
   >> make modules_install
   # ...
   >> cp -v arch/x86_64/boot/bzImage /boot/vmlinuz-5.5.13-KOPYTKO
   >> cp System.map /boot/System.map-5.5.13-KOPYTKO
   >> mkinitcpio -k 5.5.13-KOPYTKO -g /boot/initramfs-5.5.13-KOPYTKO.img
   # ...
   >> update-grub
   Generating grub configuration file ...
   Found theme: /usr/share/grub/themes/manjaro/theme.txt
   Found linux image: /boot/vmlinuz-5.5.13-KOPYTKO
   Found initrd image: /boot/intel-ucode.img /boot/amd-ucode.img /boot/initramfs-5.5.13-KOPYTKO.img
   Found linux image: /boot/vmlinuz-5.5-x86_64
   Found initrd image: /boot/intel-ucode.img /boot/amd-ucode.img /boot/initramfs-5.5-x86_64.img
   Found initrd fallback image: /boot/initramfs-5.5-x86_64-fallback.img
   Found memtest86+ image: /boot/memtest86+/memtest.bin
   #+end_src

   #+CAPTION: Nowe jądro jest widoczne w GRUBie
   [[./imgs/2_4.png]]

   #+CAPTION: Po zbootowaniu
   [[./imgs/2_5.png]]

* Zadanie 3 - kompilacja modułu
  Nie mam przykładowego modułu, dlatego posłużę się poniższym:

  #+CAPTION: ~hello.c~
  #+begin_src c
#include<linux/kernel.h>
#include<linux/module.h>
#include<linux/init.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("A Simple Hello World module");

static int __init hello_init(void)
{
  printk(KERN_INFO "Hello world!\n");
  return 0;
}

static void __exit hello_cleanup(void)
{
  printk(KERN_INFO "Goodbye world.\n");
}

module_init(hello_init);
module_exit(hello_cleanup);

  #+end_src

  #+CAPTION: ~Makefile~
  #+begin_src Makefile
obj-m += hello.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
  #+end_src

  #+CAPTION: Zbudowanie modułu
  #+begin_src bash
>> make
make -C /lib/modules/5.5.13-KOPYTKO/build M=/tmp modules
make[1]: Wejście do katalogu '/usr/src/kernels/linux-5.5.13'
  CC [M]  /tmp/hello.o
  Building modules, stage 2.
  MODPOST 1 modules
  CC [M]  /tmp/hello.mod.o
  LD [M]  /tmp/hello.ko
make[1]: Opuszczenie katalogu '/usr/src/kernels/linux-5.5.13'
  #+end_src

** Załaduj za pomocą ~insmod~
   #+CAPTION: Ładowanie za pomocą ~insmod~
   #+begin_src bash
   >> sudo insmod hello.ko
   #+end_src
** Wylistuj za pomocą ~lsmod~
   #+CAPTION: Listowanie za pomocą ~lsmod~
   #+begin_src bash
>>> sudo lsmod
Module                  Size  Used by
hello                  16384  0                       # Nasz moduł
xt_conntrack           16384  1
xt_MASQUERADE          20480  1
nf_conntrack_netlink    57344  0
nfnetlink              16384  2 nf_conntrack_netlink
xfrm_user              45056  1
xfrm_algo              16384  1 xfrm_user
xt_addrtype            16384  2
iptable_filter         16384  1
iptable_nat            16384  1
# ...
   #+end_src

** Obejrzyj komunikaty jądra za pomocą ~dmesg~
   #+CAPTION: Wyświetlenie komunikatów po załadowaniu modułu.
   #+begin_src bash
>>> sudo insmod hello.ko
>>> sudo dmesg | tail
[ 2314.602080] audit: type=1104 audit(1585237700.183:211): pid=6479 uid=0 auid=1000 ses=3 msg='op=PAM:setcred grantors=pam_unix,pam_permit,pam_env acct="root" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2336.867110] audit: type=1101 audit(1585237722.447:212): pid=6511 uid=1000 auid=1000 ses=3 msg='op=PAM:accounting grantors=pam_unix,pam_permit,pam_time acct="andrzej" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2336.867197] audit: type=1110 audit(1585237722.447:213): pid=6511 uid=0 auid=1000 ses=3 msg='op=PAM:setcred grantors=pam_unix,pam_permit,pam_env acct="root" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2336.867991] audit: type=1105 audit(1585237722.447:214): pid=6511 uid=0 auid=1000 ses=3 msg='op=PAM:session_open grantors=pam_limits,pam_unix,pam_permit acct="root" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2336.869234] Hello world!
[ 2336.869485] audit: type=1106 audit(1585237722.450:215): pid=6511 uid=0 auid=1000 ses=3 msg='op=PAM:session_close grantors=pam_limits,pam_unix,pam_permit acct="root" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2336.869528] audit: type=1104 audit(1585237722.450:216): pid=6511 uid=0 auid=1000 ses=3 msg='op=PAM:setcred grantors=pam_unix,pam_permit,pam_env acct="root" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2338.100884] audit: type=1101 audit(1585237723.680:217): pid=6521 uid=1000 auid=1000 ses=3 msg='op=PAM:accounting grantors=pam_unix,pam_permit,pam_time acct="andrzej" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2338.100971] audit: type=1110 audit(1585237723.680:218): pid=6521 uid=0 auid=1000 ses=3 msg='op=PAM:setcred grantors=pam_unix,pam_permit,pam_env acct="root" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2338.101796] audit: type=1105 audit(1585237723.683:219): pid=6521 uid=0 auid=1000 ses=3 msg='op=PAM:session_open grantors=pam_limits,pam_unix,pam_permit acct="root" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
   #+end_src

** Usuń za pomocą ~rmmod~ i wyświetl komunikaty jądra.
#+CAPTION: Wyświetlenie komunikatów po usunięciu modułu.
   #+begin_src bash
>>> sudo rmmod hello
>>> sudo dmesg | tail
[ 2338.108594] audit: type=1104 audit(1585237723.690:221): pid=6521 uid=0 auid=1000 ses=3 msg='op=PAM:setcred grantors=pam_unix,pam_permit,pam_env acct="root" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2496.807056] audit: type=1101 audit(1585237882.387:222): pid=6561 uid=1000 auid=1000 ses=3 msg='op=PAM:accounting grantors=pam_unix,pam_permit,pam_time acct="andrzej" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2496.807138] audit: type=1110 audit(1585237882.387:223): pid=6561 uid=0 auid=1000 ses=3 msg='op=PAM:setcred grantors=pam_unix,pam_permit,pam_env acct="root" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2496.807971] audit: type=1105 audit(1585237882.387:224): pid=6561 uid=0 auid=1000 ses=3 msg='op=PAM:session_open grantors=pam_limits,pam_unix,pam_permit acct="root" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2496.808780] Goodbye world.
[ 2496.839289] audit: type=1106 audit(1585237882.420:225): pid=6561 uid=0 auid=1000 ses=3 msg='op=PAM:session_close grantors=pam_limits,pam_unix,pam_permit acct="root" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2496.839337] audit: type=1104 audit(1585237882.420:226): pid=6561 uid=0 auid=1000 ses=3 msg='op=PAM:setcred grantors=pam_unix,pam_permit,pam_env acct="root" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2498.034229] audit: type=1101 audit(1585237883.613:227): pid=6569 uid=1000 auid=1000 ses=3 msg='op=PAM:accounting grantors=pam_unix,pam_permit,pam_time acct="andrzej" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2498.034315] audit: type=1110 audit(1585237883.613:228): pid=6569 uid=0 auid=1000 ses=3 msg='op=PAM:setcred grantors=pam_unix,pam_permit,pam_env acct="root" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
[ 2498.035112] audit: type=1105 audit(1585237883.617:229): pid=6569 uid=0 auid=1000 ses=3 msg='op=PAM:session_open grantors=pam_limits,pam_unix,pam_permit acct="root" exe="/usr/bin/sudo" hostname=? addr=? terminal=/dev/pts/0 res=success'
   #+end_src

** Zapoznaj się z dokładniej z komendą ~dmseg~
   Kilka przydatnych opcji.
   #+begin_example
   -w - opcja pozwala na obserwowanie komunikatów na żyw
   -H, --human - opcja dodaje kolorowanie
   --level=... - pozwala na filtrowanie wiadomości np. tylko błędy
   #+end_example

* Zadanie 4 - uruchamianie jądra w QEMU
  Jako rootfs będę używał obraz pobrany z https://alpinelinux.org/downloads/ z kategorii ~MINI ROOT FILESYSTEM~.

** Rootfs
   #+CAPTION: Pobranie
   #+begin_src bash
   >> cd /tmp
   >> wget -O alpine.tar.gz http://dl-cdn.alpinelinux.org/alpine/v3.11/releases/x86_64/alpine-minirootfs-3.11.5-x86_64.tar.gz
   >> mkdir qemu && cd rootfs
   >> tar xf ../alpine.tar.gz
   # można się schrootować
   >> sudo chroot . /bin/sh
   / #
   #+end_src

   Taki rootfs powinien wystarczyć na sprawdzenie czy jądro się bootuje.

   #+CAPTION: Tworzenie obrazu
   #+begin_src bash
   >> dd if=/dev/zero of=rootfs.img bs=1M count=1024
   >> mkfs.ext4 -F -L linuxroot rootfs.img
   >> sudo mkdir /mnt/rootfs
   >> sudo mount -o loop rootfs.img /mnt/rootfs
   >> df -h | grep rootfs
   /dev/loop0      976M  2,6M  907M   1% /mnt/rootfs
   >> sudo cp -r /tmp/rootfs/* /mnt/rootfs
   >> df -h | grep rootfs                             # niepotrzebnie 1GB
   /dev/loop0      976M  8,4M  901M   1% /mnt/rootfs
   >> sudo umount /mnt/rootfs
   #+end_src

** Kopiowanie potrzebnych plików na hosta
   QEMU mam zainstalowanie na hoście, więc kopiuję tam potrzebne pliki.

   #+begin_src bash
   >> cp /tmp/rootfs.img /mnt/hgfs/qemu-linux/                    # rootfs
   >> cp /boot/vmlinuz-5.5.13-KOPYTKO /mnt/hgfs/qemu-linux/       # jądro
   >> cp /boot/initramfs-5.5.13-KOPYTKO.img /mnt/hgfs/qemu-linux/ # initrd
   #+end_src

** Uruchamianie
   Używam następującej komendy do uruchomienia.

   #+CAPTION: Uruchamianie QEMU na hoście
   #+begin_src bat
    qemu-system-x86_64.exe -m 256 -kernel .\vmlinuz-5.5.13-KOPYTKO -hda .\rootfs.img -initrd .\initramfs-5.5.13-KOPYTKO.img -append 'root=/dev/sda'
   #+end_src

#+CAPTION: Okno QEMU
[[./imgs/4_1.png]]

Będąc w chroocie poczas tworzenia obrazu zapomniałem ustawić hasło.
Przez to teraz nie mogę się zalogować.
Ale widać, że obraz i wersja jądra się zgadzają.

* Zadanie 5 — kompilacja jądra UML
** Wykonaj komendę ~make ARCH=um defconfig~. Co ona robi?
   #+begin_src bash
   >> make help | grep defconfig
   defconfig       - New config with default from ARCH supplied defconfig
   #+end_src

   Polecenie updatuje plik ~.config~ wartościami podanymi w pliku ~arch/um/x86_64_defconfig~.
   
** Skompiluj jądro komendą ~make ARCH=um~. Ile czasu zajęła kompilacja?
   #+begin_src bash
   >> time (make -j8 ARCH=um)
   # ...
   295,76s user 34,94s system 690% cpu 47,922 total
   #+end_src

   Zajęło 48 sekund. 
   Wygląda na to, że jądro kompilowane pod UML nie potrzebuje zbyt dużo ficzerów.

** Ustawienie hasła w obrazie ~rootfs~
   Zapomniałem o tym poprzednim razem.

   #+CAPTION: Ustawienia hasła dla obrazu
   #+begin_src bash
   >> mount /tmp/rootfs.img /mnt/rootfs
   >> chroot /mnt/rootfs /bin/sh
   / # passwd
   Changing password for root
   New password:
   Bad password: too short
   Retype password:
   passwd: password for root changed by root
   / # exit
   >> umount /mnt/rootfs
   #+end_src

   Dodaję jeszcze wpis do ~/mnt/rootfs/etc/fstab~, bo inaczej obraz nie będzie montowany:
   #+CAPTION: Nowy wpis w /mnt/rootfs/etc/fstab
   #+begin_src 
   /dev/ubd0 / ext4 defaults 0 0
   #+end_src

** Uruchamianie
   #+CPATION: Uruchamianie jądra skompilowanego pod UM
   #+begin_src bash
   >> ./vmlinux ubd0=/tmp/rootfs.img mem=128M init=/bin/sh rw
   #+end_src

   #+CAPTION: Po uruchomieniu
   [[./imgs/5_1.png]]

   Wygląda na to, że ~make ARCH=um defconfig~ ucięło dopiskę ~-KOPYTKO~.

** Zamontuj hostfs
   #+begin_src bash
   / # mkdir host
   / # mount none /host -t hostfs
   #+end_src

   Pod ~/host~ mamy teraz dostęp do systemu plików hosta.
   Możemy dodawać/usuwać/edytować pliki.

** Jakie procesy są widoczne w gościu i po stronie hosta?
    #+CAPTION: Host
    #+begin_src bash
>> ps -aux | grep vm
root        215  0.0  0.0      0     0 ?        I<   18:54   0:00 [nvme-wq]
root        216  0.0  0.0      0     0 ?        I<   18:54   0:00 [nvme-reset-wq]
root        217  0.0  0.0      0     0 ?        I<   18:54   0:00 [nvme-delete-wq]
root        354  0.0  0.0  78064  1240 ?        Ss   18:54   0:00 /usr/bin/lvmetad -f
root        642  0.0  0.0      0     0 ?        S    18:54   0:00 [irq/16-vmwgfx]
root        652  0.0  0.0 163524   576 ?        Ssl  18:54   0:00 vmhgfs-fuse .host:F/ /mnt/hgfs -o rw,allow_other,uid=1000,dev,suid
root        669  0.0  0.0 161272  7328 ?        Ssl  18:54   0:00 /usr/bin/vmtoolsd
andrzej   21397  0.0  0.1 133656 12144 pts/0    S+   19:11   0:00 ./vmlinux ubd0=/tmp/rootfs.img mem=128M init=/bin/sh rw
andrzej   21402  0.0  0.1 133656 12144 pts/0    S+   19:11   0:00 ./vmlinux ubd0=/tmp/rootfs.img mem=128M init=/bin/sh rw
andrzej   21403  0.0  0.1 133656 12144 pts/0    S+   19:11   0:00 ./vmlinux ubd0=/tmp/rootfs.img mem=128M init=/bin/sh rw
andrzej   21404  0.0  0.0   3400  1352 pts/0    t+   19:11   0:00 ./vmlinux ubd0=/tmp/rootfs.img mem=128M init=/bin/sh rw
andrzej   21496  0.0  0.0   6304  2292 pts/2    S+   19:16   0:00 grep vm    
    #+end_src

    Widać, że pojawiły się 4 procesy. Nie jestem pewien z czego to wynika. 
    Być może jeden na każdy fizczny rdzeń procesora.

    #+CAPTION: Gość
    #+begin_src bash
# Najpierw trzeba podmontować procfs
/ # mount -t proc proc proc/
/ # ps aux
PID   USER     TIME  COMMAND
   1 root      0:00 /bin/sh
   2 root      0:00 [kthreadd]
   3 root      0:00 [kworker/0:0-eve]
   4 root      0:00 [kworker/0:0H-kb]
   5 root      0:00 [kworker/u2:0-ev]
   6 root      0:00 [mm_percpu_wq]
   7 root      0:00 [ksoftirqd/0]
   8 root      0:00 [kdevtmpfs]
   9 root      0:00 [netns]
  10 root      0:00 [oom_reaper]
  11 root      0:00 [writeback]
  12 root      0:00 [kworker/u2:1]
  15 root      0:00 [kblockd]
  16 root      0:00 [blkcg_punt_bio]
  17 root      0:00 [kworker/0:1-eve]
  18 root      0:00 [kswapd0]
  19 root      0:00 [kworker/0:1H-kb]
  21 root      0:00 [jbd2/ubda-8]
  22 root      0:00 [ext4-rsv-conver]
  36 root      0:00 ps aux
    #+end_src

    Gość nie widzi procesów hosta.
